<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: piece.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: piece.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import colors from "./colors.js";
import { T, O, L, J, I, S, Z } from "./pieces.js";

const pieces = "TOLJISZ";

/** Clase que representa una pieza (tetrominó). */
class Piece {

  /**
   * Crea una instancia de la clase "Piece".
   */
  constructor() {
    this.type = pieces[pieces.length * Math.random() | 0];
    this.piece = this.create_piece();
  }

  /**
   * Devuelve una matriz dependiendo del tipo de la pieza.
   * @returns {Array&lt;Array&lt;number>>} - Matriz con forma del tipo de pieza elegida.
   */
  create_piece() {
    switch (this.type) {
      case 'T':
        return T;
      case 'O':
        return O;
      case 'L':
        return L;
      case 'J':
        return J;
      case 'I':
        return I;
      case 'S':
        return S;
      case 'Z':
        return Z;
    }
  }

  /**
   * Dibuja la pieza en la pocición indicada del canvas asignado.
   * @param {CanvasRenderingContext2D} context - Canvas a dibujar.
   * @param {number} pos_x - Pocición en x del canvas a empezar el dibujo.
   * @param {number} pos_y - Pocición en y del canvas a empezar el dibujo.
   */
  draw(context, pos_x, pos_y) {
    this.piece.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          context.fillStyle = colors[value];
          context.fillRect(pos_x + (x * 30), pos_y + (y * 30), 30, 30);
        }
      });
    });
  }

  /**
   * Rota la matriz (pieza) en la dirección asignada.
   * @param {number} dir - Dirección a rotar la pieza.
   */
  rotate(dir) {
    for (let y = 0; y &lt; this.piece.length; y++) {
      for (let x = 0; x &lt; y; x++) {
        let temp = this.piece[x][y];
        this.piece[x][y] = this.piece[y][x];
        this.piece[y][x] = temp;
      }
    }
    if (dir > 0) {
      this.piece.forEach(row => row.reverse());
    } else {
      this.piece.reverse();
    }
  }

}

export default Piece;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Piece.html">Piece</a></li><li><a href="Player.html">Player</a></li></ul><h3>Global</h3><ul><li><a href="global.html#change_display">change_display</a></li><li><a href="global.html#collide">collide</a></li><li><a href="global.html#create_matrix">create_matrix</a></li><li><a href="global.html#draw_board">draw_board</a></li><li><a href="global.html#draw_game_over">draw_game_over</a></li><li><a href="global.html#draw_pause">draw_pause</a></li><li><a href="global.html#game_over">game_over</a></li><li><a href="global.html#hard_drop">hard_drop</a></li><li><a href="global.html#level_up">level_up</a></li><li><a href="global.html#line_clear">line_clear</a></li><li><a href="global.html#merge">merge</a></li><li><a href="global.html#p_drop">p_drop</a></li><li><a href="global.html#p_move">p_move</a></li><li><a href="global.html#p_rotate">p_rotate</a></li><li><a href="global.html#play_music">play_music</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#restart">restart</a></li><li><a href="global.html#update">update</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Tue Jun 16 2020 16:47:37 GMT-0300 (Argentina Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
